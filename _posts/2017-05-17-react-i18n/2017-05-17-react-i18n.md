---
title: "Internationalisierung in ReactJS"
description: "Lerne wie du eine ReactJS App richtig internationalisiert"
author: "Preethi Kasireddy"
published_at: 2017-05-17 12:00:00.000000Z
header_source: https://unsplash.com/photos/YeO44yVTl20
categories: [react, i18n]
---

Internationalisierung ist ein gro√ües Problem. Wenn du willst, dass deine Anwendung eine weltweite Reichweite hat, dann musst du dich mit Sprachbarrieren besch√§ftigen.
Leider ist die Reise von ‚ÄûDein Geld wird bis zum 7. Juli ankommen‚Äú bis ‚ÄûVos fonds arriveront le 7 Juilet‚Äú alles andere als einfach.

Bevor deine Anwendung au√üerhalb der englisch-sprachigen Welt erfolgreich sein kann, musst du alle Strings, Daten und Zahlen an die Konventionen der verschiedenen Kulturen anpassen.
Die Entwickler nennen diesen Prozess Internationalisierung (abgek√ºrzt als ‚Äûi18n‚Äú , weil es 18 Buchstaben zwischen dem ‚ÄûI‚Äú und dem ‚Äûn‚Äú des englischen Worts Internationalization gibt.)

Ein Grund, warum wir uns mit der Internationalisierung besch√§ftigten ist ganz einfach deshalb, weil es schwer ist, sie richtig umzusetzen. Jede Sprache hat andere Regeln und Konventionen. Sich an diese Regeln und Konventionen anzupassen kostet Zeit und M√ºhe.

### Die L√∂sung: React Intl

Aber die Internationalisierung muss nicht schwierig sein, dank eines neuen ReactJS-Moduls. `React Intl` ist ein open-source Projekt von Yahoo und ein Teil von *Format.js*, einer Sammlung von JavaScript Modulen f√ºr Internationalisierung die auf der integrierten Intl API von Javascript aufbaut.

Die *React Intl* Modul macht die Internationalisierung in ReactJS einfach, und zwar mit off-the-shelf Komponenten und einer API, die alles von der Formatierung von Strings, Daten und Zahlen bis hin zur Pluralisierung h√§ndeln kann.
Lass uns das ganze mal durchgehen.

### Kernkonzepte
Hier sind die Kernkonzepte, die du brauchst, um das meiste aus React Intl rauszuholen:

## Die Internationalisierung API von JavaScript
JavaScript hat eine *Internationalisierung API* Spezifikation, die das `Intl` Objekt als Standart-integriertes globales Objekt definiert.
React Intl verwendet und baut im Wesentlichen auf diese API auf. Solange der Browser diese APIs unterst√ºtzt, wird React Intl weiterhin seine Magie wirken.
*Hinweis: Der einzige Browser, der diese APIs derzeit nicht unterst√ºtzt, ist Safari. Wir benutzen ein polyfill, um das Problem im Beispielprojekten unten aus dem Weg zu r√§umen. *

## Modul-B√ºndler
React Intl vertreibt sein Paket √ºber ES6-, CommonJS- und UMD-Module. Daher funktioniert das Ganze gut mit B√ºndlern wie Webpack, Browserify und Rollup.
In dem Beispielprojekt benutzen wir Webpack als unseren Modul-B√ºndler.
Wenn du nicht planst einen Modul B√ºndler zu nutzen, um React Intl in deine Anwendung zu laden, dann empfehle ich die Dokumentation f√ºr mehr Informationen mit anderen Herangehensweisen (z.B. √ºber Node.js).

## Lokale Daten laden
React Intl st√ºtzt sich auf diese lokalen Daten, um die plural und relative-time Formatierung zu unterst√ºtzen. Lokale Daten definieren f√ºr jedes einzelne Gebietsschema Folgendes:

- Lokalspezifische Muster f√ºr die Formatierung und Zerlegung der Daten, Zeiten, Zeitzonen, Nummern und W√§hrungswerten
- √úbersetzungen von Namen, W√§hrungen, Epochen, Monaten, Wochentagen, etc.
- Sprach-und Scriptinformationen (Mehrzahl, verwendete Zeichen und Buchstaben, Geschlecht auf Listen, Kapitalisierung, Schreibrichtung, etc.
- L√§nderinformationen (W√§hrung, bevorzugter Kalender, Wochenkonventionen, Telefoncodes, etc.)

Wenn du Browserify, Webpack oder Rollup benutzt, um React Intl f√ºr den Browser zu b√ºndeln, dann enth√§lt es die locale data standartm√§√üig nur f√ºr Basis-Englisch. Der Rest von locale data ist NICHT in der Haupt-library enthalten. Deshalb werden wir in diesem Beispielprojekt behandeln, wie man locale data mit der Sprache deiner Wahl importiert, die du f√ºr deine App verwenden m√∂chtest.



### Daten formatieren mit ReactJS Komponenten vs. Die API
Das Modul bietet zwei M√∂glichkeiten, um Strings, Nummern und Daten zu formatieren: `ReactJS Komponenten` oder eine `API`.

## ReactJS Komponente

```javascript
<FormattedMessage
  id="Tooltip.fees"
  defaultMessage="Click here to understand how we calculate fees." />
```

## API

```javascript
const messages = defineMessages({
  feesMessage: {
    id: "Tooltip.fees",
    defaultMessage: ‚ÄúClick here to understand how we calculate fees.‚Äù,
  },
});

formatMessage(messages.feesMessage);
```

Wann immer m√∂glich, nehme ich den ersten Ansatz mit deklarativen idiomatisch-React-Komponenten, um Daten √ºber die imperative API zu formatieren.

Der Vorteil dieses Ansatzes ist, dass es

a) erm√∂glicht, Komponenten mit anderen Komponenten zusammenzustellen,

b) erm√∂glicht, Texte und Strings optimal zu formatieren,

c) prop type Warnungen f√ºr Optionen zur Formatierung bietet, und

d) *shouldComponentUpdate* implementiert, um teure Formatierungsprozesse zu vermeiden.

Nat√ºrlich gibt es F√§lle, bei denen deine einzige M√∂glichkeit die Nutzung einer API ist (zum Beispiel: einen String als St√ºtze, ein Namensattribut eines HTML-Elements, etc.), deshalb ist das auch immer noch praktisch.

#### Beispielprojekt

Ein Live Beispiel zu sehen, ist die beste Art zu lernen. F√ºr diesen Beitrag habe ich ein einfaches ReactJS-Projekt erstellt, das aus einer Haupt Header-Komponente, einer Subheader Komponente und einigen Widged-Komponenten besteht, die jeweils ihre eigenen Header und Body‚Äòs haben.

Als erstes gehen wir den Prozess durch, in dem wir React Intl einstellen. Danach benutzen wir die Komponenten und API um Strings, Nummern, und Daten, die in den Komponenten verwendet werden, zu konvertieren.

#### Einrichten
Nehmen wir an, wir haben eine bestehende ReactJS-Anwendung, von der aus wir arbeiten. Zuerst musst du das React Intl Paket installieren:

```shell
npm install ‚Äî-save react-intl
```

Als n√§chstes installieren wir das Babel Plugin f√ºr `React Intl`:

```shell
npm install --save-dev babel-plugin-react-intl
```

Um das Babel Plugin seine Magie tats√§chlich wirken zu lassen, m√ºssen wir unseren `.babelrc` Datei einrichten, um das Plugin einzuf√ºgen. Hier siehst du, wie meine `babelrc`, mit dem React-Intl Plugin dazu angef√ºgt, aussieht (Zeilen 6-11):

 ```javascript
{
  "presets": ["es2015", "react", "stage-0"],
  "plugins": [
    "transform-object-rest-spread",
    "transform-runtime",
    [
      "react-intl", {
        "messagesDir": "./build/messages",
        "enforceDescriptions": false
      }
    ]
  ],
  "env": {
     "development": {
      "presets": ["react-hmre"]
     }
  }
}
```

Dieses Babel Plugin extrahiert alle String Meldungen in deine Anwendung, die entweder mit defineMessages. `<FormattedMessage>`, oder `<FormattedHTMLMessage>` definiert sind.

(Beachte, dass `defineMessages`, `<FormattedMessage>`, und `<FormattedHTMLMessage>` alle Exporte aus dem React Intl Paket sind).

Sobald alles extrahiert ist, werden JSON Dateien generiert, die die String Meldungen enthalten und platziert sie in das Verzeichnis, das du im `messagesDir` Pfad oben definiert hast.

#### Daten laden

Als n√§chsten laden wir die entsprechenden locale data f√ºr die Sprachen, die wie wir ben√∂tigen.

Wie oben bereits erw√§hnt, wenn du Webpack, Browserify oder Rollup benutzt, um den Browser zu b√ºndeln, wird React Intl standartm√§√üig nur auf English erscheinen. In der root Komponenten-Datei f√ºgen wir die locale Data mit der `addLocaleData` API ein. Die Daten werden dann die Inhalte des locale data Moduls passieren. Dann werden sie in ihrer locale data registry registriert.

F√ºr dieses Beispielprojekt nehme ich an, dass wir 4 Sprachen unterst√ºtzen wollen: Englisch, Spanisch, Franz√∂sisch und Italienisch.

```javascript
import { addLocaleData } from ‚Äòreact-intl‚Äô;
import en from ‚Äòreact-intl/locale-data/en‚Äô;
import es from ‚Äòreact-intl/locale-data/es‚Äô;
import fr from ‚Äòreact-intl/locale-data/fr‚Äô;
import it from ‚Äòreact-intl/locale-data/it‚Äô;

addLocaleData([...en, ...es, ...fr, ...it]);
```

_Hinweis: Wenn deine App viel mehr unterst√ºtzt, empfiehlt es sich, die locale data basierend auf der Sprache des aktuellen Benutzers dynamisch zu laden. Lies die React Intl docs f√ºr weitere Informationen zu diesem Ansatz._

#### Erstelle den i18n Kontext in deiner React Anwendlung
Bisher haben wir das React Intl Paket installiert, unser `.babelrc` Plugin eingestellt und die entsprechenden locale data geladen.

Ein letzter Schritt besteht darin, einen i18n Kontext f√ºr alle unsere React-Komponenten zu erstellen, so dass die locale und die √úbersetze Nachricht des derzeitigen Nutzers (auf dem Ort des Nutzers basierend) in die React Intl Komponente geladen werden kann, die du in deiner App definierst.

Um dies zu tun, definieren wir zuerst die Nachrichten, die an den `IntlProvider` basierend auf dem Ort des Nutzers gegeben werden (_siehe Zeilen 18-26 unten_). Dann integrieren wir die root React-Komponente mit `IntlProvider`, ein benannter Export von React-Intl (_siehe Zeilen 31-33_):

```javascript
import React from 'react';
import { render } from 'react-dom';
import App from './components/App/index';
import { IntlProvider, addLocaleData } from 'react-intl';
import en from 'react-intl/locale-data/en';
import es from 'react-intl/locale-data/es';
import fr from 'react-intl/locale-data/fr';
import it from 'react-intl/locale-data/it';

// Our translated strings
import localeData from './../../build/locales/data.json';

addLocaleData([...en, ...es, ...fr, ...it]);

// Define user's language. Different browsers have the user locale defined
// on different fields on the `navigator` object, so we make sure to account
// for these different by checking all of them
const language = (navigator.languages && navigator.languages[0]) ||
                     navigator.language ||
                     navigator.userLanguage;

// Split locales with a region code
const languageWithoutRegionCode = language.toLowerCase().split(/[_-]+/)[0];

// Try full locale, try locale without region code, fallback to 'en'
const messages = localeData[languageWithoutRegionCode] || localeData[language] || localeData.en;

// Render our root component into the div with id "root"
// We select the messages to pass to IntlProvider based on the user's locale
render(
  <IntlProvider locale={language} messages={messages}>
    <App />
  </IntlProvider>,
  document.getElementById('root')
);
```

In diesem Setup gehen wir davon aus, dass unsere √ºbersetzten Daten in `build/locales/data.json` sind und dass die Daten nach Sprache gruppiert werden:

```javascript
{
  en: {
    ...English version of strings,
  },
  fr: {
    ...French version of strings,
  },
  es: {
    ...Spanish version of strings,
  }
  ... etc.
}

```

#### Erstelle ein Script f√ºr die √úbersetzung

Nun da wir alles fertig konfiguriert haben, schauen wir uns mal an, wie wir ein einfaches Script erstellen k√∂nnen, dass alle Strings verwendet, die Babel f√ºr uns in mehrere JSON-Dateien extrahiert und kombinieren sie zu einer Datei.

Der Sinn dieses Scripts ist alle Englischen Strings anzusammeln, so dass wir sie dann zu einem √úbersetzungsdienst hochladen k√∂nnen, sie in verschiedene Sprachen √ºbersetzen und dann die Ergebnisse in die `build/locales/data.json` Datei platzieren, die wir oben benutzt haben. Dort kann die `IntlProvider` Komponente schlie√ülich unsere root Komponente laden.

Da wir die √úbersetzungen in diesem Beitrag nicht ganz machen m√ºssen, √ºberspringen wir diesen Schritt und erstellen einfach nur ein Script, welches alles in eine Datei bringt. Denke nur daran, in einen √úbersetzungsdienst Anbieter in Echt-Welt-Anwendungen üòä

Alle Gutschriften gehen an das React Intl Modul Autoren f√ºr das Generieren von diesem Script unten:

```javascript
import * as fs from 'fs';
import { sync as globSync } from 'glob';
import { sync as mkdirpSync } from 'mkdirp';

const filePattern = './build/messages/**/*.json';
const outputDir = './build/locales/';

// Aggregates the default messages that were extracted from the example app's
// React components via the React Intl Babel plugin. An error will be thrown if
// there are messages in different components that use the same `id`. The result
// is a flat collection of `id: message` pairs for the app's default locale.
let defaultMessages = globSync(filePattern)
  .map((filename) => fs.readFileSync(filename, 'utf8'))
  .map((file) => JSON.parse(file))
  .reduce((collection, descriptors) => {
    descriptors.forEach(({id, defaultMessage}) => {
      if (collection.hasOwnProperty(id)) {
        throw new Error(`Duplicate message id: ${id}`);
      }
      collection[id] = defaultMessage;
    });

    return collection;
  }, {});
// Create a new directory that we want to write the aggregate messages to
mkdirpSync(outputDir);

// Write the messages to this directory
fs.writeFileSync(outputDir + 'data.json', `{ "en": ${JSON.stringify(defaultMessages, null, 2)} }`);

```
#### Schritte um Daten, Nummern und Strings in React Intl zu konvertieren
Okay ‚Äì wir sind endlich bereit, um ein bisschen zu formatieren!
Die Beispiel-App hat ein einfaches Layout mit einem`header`, `subheader`, und `widgets`, die jeweils Strings, Nummern und/oder Daten enthalten:
[FOTO]
Nichts Anspruchsvolles, aber es ist genug, um loszulegen.

## Header
Zuerst schauen wir uns den Header an, in dem steht: *‚ÄúWillkommen in deinem dashboard, Preethi!‚Äú*
Um das zu konvertieren, benutzen wir die `FormattedMessage` Komponente:
```javascript
<FormattedMessage
  id={ 'Header.greeting' }
  defaultMessage={ 'Welcome to your dashboard, {name}!' }
  values={{ name: this.props.name }}
/>
```

Die `FormattedMessage` Komponente verf√ºgt √ºber Requisiten, die mit einem ‚Äû`Message Descriptor`‚Äú in React Intl korrespondieren.

Der `Message Descriptor` ist das Format, das verwendet wird, um Standartzeichen / Strings zu definieren und das ist n√ºtzlich f√ºr die Bereitstellung der Daten, die erforderlich sind, damit die Zeichenfolgen / Nachrichten √ºbersetzt werden. Es enth√§lt folgende Eigenschaften:

- `id`: ein spezieller, stabiler Identifizierer f√ºr die Nachricht/Zeichen
- `description`: Kontext f√ºr den √úbersetzer dar√ºber, wie es in dem UserInterface verwendet wird (optional)
- `defaultMessage` Die default message (auf Englisch)

Die `id` muss f√ºr jede in deiner App definierte Nachricht eindeutig sein.

Es ist super, dass die `defaultMessage` Daten von den props √ºbermitteln kann, wie in dem Fall f√ºr `name` oben (beachte, dass die Werte, die als Daten √ºbrgeben werden, nicht √ºbersetzt werden ‚Äì sie werden einfach in die endg√ºltig √ºbersetzte Zeichenfolge eingef√ºgt.)

## Subheader

Lass uns als n√§chstes den Subheader betrachten, der etwas st√§rker beteiligt ist:

```javascript
<FormattedMessage
  id={ 'SubHeader.unreadCount' }
  defaultMessage={ 'You have {unreadCount} new {notifications}' }
  values={{
    unreadCount: (
      <b>
        <FormattedNumber
          value={ unreadCount }
        />
      </b>
    ),
    notifications: (
      <FormattedPlural
        value={ unreadCount }
        one="notification"
        other="notifications"
      />
    ),
  }}
/>

```

Die F√§higkeit, Komponenten in andere Komponenten zu komponieren (d.H. `Formatted` Elemente innerhalb eines anderen `Formatted` Elements haben) ist ein starkes Feature von React Intl.


Du kannst in dem obigen Beispiel sehen, dass `unreadCount` eine `FormattedNumber` und `notifications` ein `FormattedPlural` ist, und dass beides Werte sind, die in `FormattedMessages`‚Äòs `defaultMessage` √ºbertragen wurden. Sch√∂n!


Eine weitere super Funktion ist `FormattedRelative`, welche die formatierte relative Zeit rendert.

```javascript
<FormattedMessage
  id={ 'SubHeader.lastLogin' }
  defaultMessage={ 'You last logged in {time}!' }
  values={{ time: <FormattedRelative value={ this.props.lastLogin } /> }}
/>
```

Sobald es √ºbersetzt und formatiert ist, lautet es: *‚ÄùYou last logged in 4 hours ago!‚Äù* (oder wann auch immer der letzte Login war.)

#### √úbergeben von formatierten Strings als Komponenten

In den obigen zwei Snippets haben wir gesehen, wie wir die `Formatted`* Komponenten benutzen, um Strings, Nummern, Daten und Pluralisierung zu definieren.

Allerdings gibt es viele Beispiele, wo es n√∂tig ist formatierte Strings als Requisiten zu √ºbergeben oder formatierte Strings zu verwenden, um eine HTML-Komponente zu bennenen. Die `FormattedMessage` Komponente funktioniert in solchen F√§llen nicht gut.

Gl√ºcklicherweise l√§sst uns React Intl‚Äôs `defineMessages` API alle Komponenten der Strings definieren und dann als props zur Komponente √ºbergeben.

Lass uns diesen Ansatz f√ºr die Widget-Header und Body ausprobieren. Zuerst nutzen wir `defineMessages`, um unsere Strings zu definieren.

```javascript

const messages = defineMessages({
  widget1Header: {
    id: 'Widgets.widget1.header',
    defaultMessage: 'Creative header',
  },
  widget1Body: {
    id: 'Widgets.widget1.body',
    defaultMessage: 'Mark todays date: {date}',
  },
  widget2Header: {
    id: 'Widgets.widget2.header',
    defaultMessage: 'Here is another widget',
  },
  widget2Body: {
    id: 'Widgets.widget2.body',
    defaultMessage: 'Hello. How is your day going?',
  },
  widget3Header: {
    id: 'Widgets.widget3.header',
    defaultMessage: 'Yet another widget',
  },
  widget3Body: {
    id: 'Widgets.widget3.body',
    defaultMessage: 'What is the meaning of life, my friend?',
  },
  widget4Header: {
    id: 'Widgets.widget4.header',
    defaultMessage: 'This is the last widget',
  },
  widget4Body: {
    id: 'Widgets.widget4.body',
    defaultMessage: 'I love React so much!',
  },
});

```
Dann, vorrausgesetzt wir habe eine Widget Komponente, die Kopf und Body Requisiten erwartet, k√∂nnen wir so weitermachen:

```javascript
<Widget
  header={ formatMessage(messages.widget1Header) }
  body={ formatMessage(messages.widget1Body, {
    date: formatDate(this.props.currentDate, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    }),
  }) }
/>

<Widget
  header={ formatMessage(messages.widget2Header) }
  body={ formatMessage(messages.widget2Body) }
/>

<Widget
  header={ formatMessage(messages.widget3Header) }
  body={ formatMessage(messages.widget3Body) }
/>

<Widget
  header={ formatMessage(messages.widget4Header) }
  body={ formatMessage(messages.widget4Body) }
/>

```

Eine Sache, die du vielleicht beim ersten Widget bemerkt hast, ist, dass wir auch Daten an die in `defineMessages` definierten Strings √ºbergeben k√∂nnen. Hier haben wir das aktuell formatierte Datum als den Wert `date` √ºbergeben. Ziemlich nett, oder?

Die API funktioniert auch gut f√ºr die Formatierung von Zahlen, Zeiten, relativen Zeiten und Pluralisierung (sieh dir ihre docs f√ºr mehr dazu an)

#### Wie man es in Safari zum funktionieren bringt

Jetzt, da wir fast fertig sind, haue ich nochmal ein paar Informationen hierzu raus.
Das aktuelle Setup funktioniert nicht f√ºr Safari Browser üôÉ.

Wie oben erw√§hnt, liegt das daran, dass Safari zur Zeit keine Unterst√ºtzung f√ºr Javascript‚Äôs Internationalisierung API hat.

Gl√ºcklicherweise gibt es trotzdem einen Weg, damit das auch f√ºr Safari Nutzer klappt. Was wir tun m√ºssen, ist den `Intl Polyfill` zu benutzen. Es gibt einige M√∂glichkeiten, um das zu laden. Lass uns f√ºr dieses Beispiel weiterhin Webpack benutzen:


Zuerst installieren wir das intl Paket von npm:

```shell
npm install --save intl
```

Als n√§chstes schreiben wir eine einfache if-Anweisung, um nur den Polyfill zu laden, wenn es keine Browserunterst√ºtzung f√ºr `Intl` gibt (siehe Zeilen 30-57). Das wird getan, um das Laden des Moduls und aller locale Daten in die App zu verhindern, wenn es nicht gebraucht wird.

```javascript
import React from 'react';
import { render } from 'react-dom';
import App from './components/App/index';
import { IntlProvider, addLocaleData } from 'react-intl';
import en from 'react-intl/locale-data/en';
import es from 'react-intl/locale-data/es';
import fr from 'react-intl/locale-data/fr';
import it from 'react-intl/locale-data/it';
import localeData from './../../build/locales/data.json';

addLocaleData([...en, ...es, ...fr, ...it]);

// Define user's language. Different browsers have the user locale defined
// on different fields on the `navigator` object, so we make sure to account
// for these different by checking all of them
const language = (navigator.languages && navigator.languages[0]) ||
                     navigator.language ||
                     navigator.userLanguage;

// Split locales with a region code
const languageWithoutRegionCode = language.toLowerCase().split(/[_-]+/)[0];

// Try full locale, fallback to locale without region code, fallback to en
const messages = localeData[languageWithoutRegionCode] || localeData[language] || localeData.en;

// Render our root component into the div with id "root"

// If browser doesn't support Intl (i.e. Safari), then we manually import
// the intl polyfill and locale data.
if (!window.intl) {
  require.ensure([
    'intl',
    'intl/locale-data/jsonp/en.js',
    'intl/locale-data/jsonp/es.js',
    'intl/locale-data/jsonp/fr.js',
    'intl/locale-data/jsonp/it.js',
  ], (require) => {
    require('intl');
    require('intl/locale-data/jsonp/en.js');
    require('intl/locale-data/jsonp/es.js');
    require('intl/locale-data/jsonp/fr.js');
    require('intl/locale-data/jsonp/it.js');
    render(
      <IntlProvider locale={language} messages={messages}>
        <App />
      </IntlProvider>,
      document.getElementById('root')
    );
  });
} else {
  render(
    <IntlProvider locale={language} messages={messages}>
      <App />
    </IntlProvider>,
    document.getElementById('root')
  );
}
```

Wie du sehen kannst, ist das erste, was zu √ºberpr√ºfen ist, ob die `intl` global *nicht* im Fenster verf√ºgbar ist. Wenn nicht, dann laden wir die intl polyfill und zugeh√∂rige locale data und rendern dann die Komponente. Ansonsten rendern wir einfach die Komponente.

Und nun ist unsere vor√ºbersetzte App (nat√ºrlich noch immer auf Englisch) endlich da. Ich werde dir noch einen finalen Schritt zeigen, der beinhaltet einen translation provider zu finden und diese Strings √ºbersetzen zu lassen.

#### Andere Tipps

Ich hoffe, dieser Beitrag ist genug, um deine React Anwendung in eine solche zu verwandeln, die f√ºr andere Kulturen und Sprachen zug√§nglich ist.

Bevor ich mich f√ºr heute abmelde, hier sind ein paar weitere Tipps, die zu beachten sind, wenn man seine App internationalisiert.

- Flexible Komponennten: Baue deine Komponenten so ein, dass sie flexibel sind und eine Textausweitung bzw. Schrumpfung erm√∂glichen. Manche Sprachen k√∂nnen sich viel gr√∂√üer erweitern oder kleiner schrumpfen als Englisch.

- Angemessene Schriftgr√∂√üe: Verwende eine Schriftgr√∂√üe, die mit allen Sprachen, die du unterst√ºtzen willst, gut funktioniert. Manche Sprachen, wie Japanische oder Chinesisch, brauchen eine gr√∂√üere Schrift.

- UTF-8: Benutze UTF-8 √ºberall. Dies beinhaltet auch deine HTML, server-side language, Datenbank, etc. Im Gegensatz zu anderen Codierungen, kann UTF-8 fast alle Sprachen sehr gut h√§ndeln.

- Kein Text in Bildern: Vermeide es, Text in Bildern zu verwenden, weil die √úbersetzung von Text in Bildern extrem schwierig ist und den ganzen Aufwand nicht wert ist.

- Teile deine Strings nicht auf: Zum Beispiel, wenn du ‚ÄûYour funds will arrive by July 7th‚Äú hast, vermeide es sie aufzuteilen wie ‚ÄûYour funds will arrive by‚Äú und ‚ÄûJuly 7th‚Äú. Diese Kombination mag aufgrund von Wortordnungsvariationen anderer Sprachen, vielleicht nur auf Englisch funktionieren.

#### Fazit

F√ºhl dich wie immer frei mit Fragen oder Anregungen zu kommentieren. Ich w√ºrde mich freuen diese zu beantworten üòä
Der ganze Code f√ºr die Beispiel-Anwendung kann bei GitHub hier gefunden werden:

[https://github.com/workshops-de/inbox-react-intl](https://github.com/workshops-de/inbox-react-intl)

#### Credits

Original gepostet von [Preethi Kasireddy](https://twitter.com/iam_preethi) auf [FreeCodeCamp ‚Äì Medium](https://www.freecodecamp.org/news/internationalization-in-react-7264738274a0/).


